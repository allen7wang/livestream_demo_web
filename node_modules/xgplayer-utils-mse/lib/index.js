'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _xgplayerTransmuxerConstantEvents = require('xgplayer-transmuxer-constant-events');

var _xgplayerTransmuxerConstantEvents2 = _interopRequireDefault(_xgplayerTransmuxerConstantEvents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MSE_EVENTS = _xgplayerTransmuxerConstantEvents2.default.MSE_EVENTS;

var MSE = function () {
  function MSE(configs, context) {
    _classCallCheck(this, MSE);

    if (context) {
      this._context = context;
      this.emit = context._emitter.emit.bind(context._emitter);
    }

    this.TAG = 'MSE';

    this.configs = Object.assign({}, configs);
    this.container = this.configs.container;
    this.mediaSource = null;
    this.sourceBuffers = {};
    this.preloadTime = this.configs.preloadTime || 1;
    this.onSourceOpen = this.onSourceOpen.bind(this);
    this.onTimeUpdate = this.onTimeUpdate.bind(this);
    this.onUpdateEnd = this.onUpdateEnd.bind(this);
    this.onWaiting = this.onWaiting.bind(this);
    this.opened = false;
  }

  _createClass(MSE, [{
    key: 'init',
    value: function init() {
      // eslint-disable-next-line no-undef
      this.mediaSource = new self.MediaSource();
      this.mediaSource.addEventListener('sourceopen', this.onSourceOpen);
      this._url = null;
      this.container.addEventListener('timeupdate', this.onTimeUpdate);
      this.container.addEventListener('waiting', this.onWaiting);
    }
  }, {
    key: 'resetContext',
    value: function resetContext(newCtx) {
      this._context = newCtx;
      this.emit = newCtx._emitter.emit.bind(newCtx._emitter);
      for (var i = 0; i < Object.keys(this.sourceBuffers).length; i++) {
        var buffer = this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];
        if (!buffer.updating) {
          MSE.clearBuffer(buffer);
        }
      }
    }
  }, {
    key: 'onTimeUpdate',
    value: function onTimeUpdate() {
      this.emit('TIME_UPDATE', this.container);
    }
  }, {
    key: 'onWaiting',
    value: function onWaiting() {
      this.emit('WAITING', this.container);
    }
  }, {
    key: 'onSourceOpen',
    value: function onSourceOpen() {
      this.opened = true;
      this.addSourceBuffers();
    }
  }, {
    key: 'onUpdateEnd',
    value: function onUpdateEnd() {
      this.emit(MSE_EVENTS.SOURCE_UPDATE_END);
      this.doAppend();
    }
  }, {
    key: 'addSourceBuffers',
    value: function addSourceBuffers() {
      if (this.mediaSource.readyState !== 'open' || !this.opened) {
        return;
      }
      var sources = this._context.getInstance('PRE_SOURCE_BUFFER');
      var tracks = this._context.getInstance('TRACKS');
      var track = void 0;
      if (!sources || !tracks) {
        return;
      }

      sources = sources.sources;
      var add = false;
      for (var i = 0, k = Object.keys(sources).length; i < k; i++) {
        var type = Object.keys(sources)[i];
        add = false;
        if (type === 'audio') {
          track = tracks.audioTrack;
        } else if (type === 'video') {
          track = tracks.videoTrack;
          // return;
        }
        if (track && sources[type].init !== null && sources[type].data.length) {
          add = true;
        }
      }

      if (add) {
        if (Object.keys(this.sourceBuffers).length > 1) {
          return;
        }
        for (var _i = 0, _k = Object.keys(sources).length; _i < _k; _i++) {
          var _type = Object.keys(sources)[_i];
          if (this.sourceBuffers[_type]) {
            continue;
          }
          var source = sources[_type];
          var mime = _type === 'video' ? 'video/mp4;codecs=' + source.mimetype : 'audio/mp4;codecs=' + source.mimetype;

          try {
            var sourceBuffer = this.mediaSource.addSourceBuffer(mime);
            this.sourceBuffers[_type] = sourceBuffer;
            sourceBuffer.addEventListener('updateend', this.onUpdateEnd);
          } catch (e) {
            this.emit(MSE_EVENTS.MSE_ERROR, this.TAG, new Error(e.message));
          }
        }
        if (Object.keys(this.sourceBuffers).length === 2) {
          this.doAppend();
        }
      }
    }
  }, {
    key: 'doAppend',
    value: function doAppend() {
      if (Object.keys(this.sourceBuffers).length < 2) {
        return;
      }
      var sources = this._context.getInstance('PRE_SOURCE_BUFFER');
      if (sources) {
        for (var i = 0; i < Object.keys(this.sourceBuffers).length; i++) {
          var type = Object.keys(this.sourceBuffers)[i];
          var sourceBuffer = this.sourceBuffers[type];
          var source = sources.sources[type];
          if (source && !source.inited) {
            try {
              // console.log('append buffser init: ', type, source.init)
              sourceBuffer.appendBuffer(source.init.buffer.buffer);
              source.inited = true;
            } catch (e) {
              // DO NOTHING
            }
          } else if (source) {
            var data = source.data.shift();
            if (data) {
              try {
                sourceBuffer.appendBuffer(data.buffer.buffer);
              } catch (e) {
                source.data.unshift(data);
              }
            }
          }
        }
      }
    }
  }, {
    key: 'endOfStream',
    value: function endOfStream() {
      var readyState = this.mediaSource.readyState;

      if (readyState === 'open') {
        try {
          this.mediaSource.endOfStream();
        } catch (e) {
          // log
        }
      }
    }
  }, {
    key: 'remove',
    value: function remove(end) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = 0; i < Object.keys(this.sourceBuffers).length; i++) {
        var buffer = this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];
        if (!buffer.updating) {
          // console.log('remove', start, end)
          buffer.remove(start, end);
        }
      }
    }
  }, {
    key: 'cleanBuffers',
    value: function cleanBuffers() {
      var _this = this;

      var taskList = [];

      var _loop = function _loop(i) {
        var buffer = _this.sourceBuffers[Object.keys(_this.sourceBuffers)[i]];

        var task = void 0;
        if (buffer.updating) {
          task = new Promise(function (resolve) {
            var doCleanBuffer = function doCleanBuffer() {
              var retryTime = 3;

              var clean = function clean() {
                if (!buffer.updating) {
                  MSE.clearBuffer(buffer);
                  buffer.addEventListener('updateend', function () {
                    resolve();
                  });
                } else if (retryTime > 0) {
                  setTimeout(clean, 200);
                  retryTime--;
                } else {
                  resolve();
                }
              };

              setTimeout(clean, 200);
              buffer.removeEventListener('updateend', doCleanBuffer);
            };
            buffer.addEventListener('updateend', doCleanBuffer);
          });
        } else {
          task = new Promise(function (resolve) {
            MSE.clearBuffer(buffer);
            buffer.addEventListener('updateend', function () {
              resolve();
            });
          });

          // task = Promise.resolve()
        }

        taskList.push(task);
      };

      for (var i = 0; i < Object.keys(this.sourceBuffers).length; i++) {
        _loop(i);
      }

      return Promise.all(taskList);
    }
  }, {
    key: 'removeBuffers',
    value: function removeBuffers() {
      var _this2 = this;

      var taskList = [];

      var _loop2 = function _loop2(i) {
        var buffer = _this2.sourceBuffers[Object.keys(_this2.sourceBuffers)[i]];
        buffer.removeEventListener('updateend', _this2.onUpdateEnd);

        var task = void 0;
        if (buffer.updating) {
          task = new Promise(function (resolve) {
            var doCleanBuffer = function doCleanBuffer() {
              var retryTime = 3;

              var clean = function clean() {
                if (!buffer.updating) {
                  MSE.clearBuffer(buffer);
                  buffer.addEventListener('updateend', function () {
                    resolve();
                  });
                } else if (retryTime > 0) {
                  setTimeout(clean, 200);
                  retryTime--;
                } else {
                  resolve();
                }
              };

              setTimeout(clean, 200);
              buffer.removeEventListener('updateend', doCleanBuffer);
            };
            buffer.addEventListener('updateend', doCleanBuffer);
          });
        } else {
          task = new Promise(function (resolve) {
            MSE.clearBuffer(buffer);
            buffer.addEventListener('updateend', function () {
              resolve();
            });
          });

          // task = Promise.resolve()
        }

        taskList.push(task);
      };

      for (var i = 0; i < Object.keys(this.sourceBuffers).length; i++) {
        _loop2(i);
      }

      return Promise.all(taskList);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this3 = this;

      this.container.removeEventListener('timeupdate', this.onTimeUpdate);
      this.container.removeEventListener('waiting', this.onWaiting);
      this.mediaSource.removeEventListener('sourceopen', this.onSourceOpen);
      return this.removeBuffers().then(function () {
        for (var i = 0; i < Object.keys(_this3.sourceBuffers).length; i++) {
          var _buffer = _this3.sourceBuffers[Object.keys(_this3.sourceBuffers)[i]];
          _this3.mediaSource.removeSourceBuffer(_buffer);
          delete _this3.sourceBuffers[Object.keys(_this3.sourceBuffers)[i]];
        }

        _this3.endOfStream();
        window.URL.revokeObjectURL(_this3.url);

        _this3.url = null;
        _this3.configs = {};
        _this3.container = null;
        _this3.mediaSource = null;
        _this3.sourceBuffers = {};
        _this3.preloadTime = 1;

        _this3.onSourceOpen = null;
        _this3.onTimeUpdate = null;
        _this3.onUpdateEnd = null;
        _this3.onWaiting = null;
      });
    }
  }, {
    key: 'url',
    set: function set(val) {
      this._url = val;
    },
    get: function get() {
      if (!this._url) {
        this._url = window.URL.createObjectURL(this.mediaSource);
      }
      return this._url;
    }
  }], [{
    key: 'clearBuffer',
    value: function clearBuffer(buffer) {
      try {
        var buffered = buffer.buffered;
        var bEnd = 0.1;
        for (var i = 0, len = buffered.length; i < len; i++) {
          bEnd = buffered.end(i);
        }
        buffer.remove(0, bEnd);
      } catch (e) {
        // DO NOTHING
      }
    }
  }]);

  return MSE;
}();

exports.default = MSE;