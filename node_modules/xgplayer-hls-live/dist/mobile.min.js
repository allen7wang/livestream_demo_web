(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('xgplayer'), require('xgplayer-transmuxer-context'), require('xgplayer-transmuxer-buffer-track'), require('xgplayer-transmuxer-buffer-xgbuffer'), require('xgplayer-transmuxer-buffer-stream'), require('xgplayer-utils-crypto'), require('xgplayer-transmuxer-demux-m3u8'), require('xgplayer-transmuxer-codec-aac'), require('xgplayer-transmuxer-codec-avc'), require('xgplayer-transmuxer-codec-hevc'), require('xgplayer-transmuxer-model-trackmeta'), require('xgplayer-transmuxer-model-tracksample')) :
  typeof define === 'function' && define.amd ? define(['xgplayer', 'xgplayer-transmuxer-context', 'xgplayer-transmuxer-buffer-track', 'xgplayer-transmuxer-buffer-xgbuffer', 'xgplayer-transmuxer-buffer-stream', 'xgplayer-utils-crypto', 'xgplayer-transmuxer-demux-m3u8', 'xgplayer-transmuxer-codec-aac', 'xgplayer-transmuxer-codec-avc', 'xgplayer-transmuxer-codec-hevc', 'xgplayer-transmuxer-model-trackmeta', 'xgplayer-transmuxer-model-tracksample'], factory) :
  (global = global || self, global.HlsLiveMobilePlayer = factory(global.Player, global.Context, global.Tracks, global.XgBuffer, global.Stream, global.Crypto, global.M3U8Parser, global.xgplayerTransmuxerCodecAac, global.xgplayerTransmuxerCodecAvc, global.xgplayerTransmuxerCodecHevc, global.xgplayerTransmuxerModelTrackmeta, global.xgplayerTransmuxerModelTracksample));
}(this, (function (Player, Context, Tracks, XgBuffer, Stream, Crypto, M3U8Parser, xgplayerTransmuxerCodecAac, xgplayerTransmuxerCodecAvc, xgplayerTransmuxerCodecHevc, xgplayerTransmuxerModelTrackmeta, xgplayerTransmuxerModelTracksample) { 'use strict';

  Player = Player && Object.prototype.hasOwnProperty.call(Player, 'default') ? Player['default'] : Player;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;
  var Tracks__default = 'default' in Tracks ? Tracks['default'] : Tracks;
  XgBuffer = XgBuffer && Object.prototype.hasOwnProperty.call(XgBuffer, 'default') ? XgBuffer['default'] : XgBuffer;
  Stream = Stream && Object.prototype.hasOwnProperty.call(Stream, 'default') ? Stream['default'] : Stream;
  Crypto = Crypto && Object.prototype.hasOwnProperty.call(Crypto, 'default') ? Crypto['default'] : Crypto;
  M3U8Parser = M3U8Parser && Object.prototype.hasOwnProperty.call(M3U8Parser, 'default') ? M3U8Parser['default'] : M3U8Parser;

  var BROWSER_EVENTS = {
    VISIBILITY_CHANGE: 'VISIBILITY_CHANGE'
  };
  var PLAYER_EVENTS = {
    SEEK: 'SEEK'
  };

  var LOADER_EVENTS = {
    LADER_START: 'LOADER_START',
    LOADER_DATALOADED: 'LOADER_DATALOADED',
    LOADER_COMPLETE: 'LOADER_COMPLETE',
    LOADER_RESPONSE_HEADERS: 'LOADER_RESPONSE_HEADERS',
    LOADER_ERROR: 'LOADER_ERROR'
  };

  var DEMUX_EVENTS = {
    DEMUX_START: 'DEMUX_START',
    DEMUX_COMPLETE: 'DEMUX_COMPLETE',
    DEMUX_ERROR: 'DEMUX_ERROR',
    METADATA_PARSED: 'METADATA_PARSED',
    SEI_PARSED: 'SEI_PARSED',
    VIDEO_METADATA_CHANGE: 'VIDEO_METADATA_CHANGE',
    AUDIO_METADATA_CHANGE: 'AUDIO_METADATA_CHANGE',
    MEDIA_INFO: 'MEDIA_INFO'
  };

  var REMUX_EVENTS = {
    REMUX_METADATA: 'REMUX_METADATA',
    REMUX_MEDIA: 'REMUX_MEDIA',
    MEDIA_SEGMENT: 'MEDIA_SEGMENT',
    REMUX_ERROR: 'REMUX_ERROR',
    INIT_SEGMENT: 'INIT_SEGMENT',
    DETECT_CHANGE_STREAM: 'DETECT_CHANGE_STREAM',
    DETECT_CHANGE_STREAM_DISCONTINUE: 'DETECT_CHANGE_STREAM_DISCONTINUE',
    RANDOM_ACCESS_POINT: 'RANDOM_ACCESS_POINT'
  };

  var MSE_EVENTS = {
    SOURCE_UPDATE_END: 'SOURCE_UPDATE_END',
    MSE_ERROR: 'MSE_ERROR'

    // hls专有events
  };var HLS_EVENTS = {
    RETRY_TIME_EXCEEDED: 'RETRY_TIME_EXCEEDED'
  };

  var CRYTO_EVENTS = {
    START_DECRYPT: 'START_DECRYPT',
    DECRYPTED: 'DECRYPTED'
  };
  var ALLEVENTS = Object.assign({}, LOADER_EVENTS, DEMUX_EVENTS, REMUX_EVENTS, MSE_EVENTS, HLS_EVENTS, PLAYER_EVENTS, BROWSER_EVENTS);

  var FlvAllowedEvents = [];
  var HlsAllowedEvents = [];

  for (var key in ALLEVENTS) {
    if (ALLEVENTS.hasOwnProperty(key)) {
      FlvAllowedEvents.push(ALLEVENTS[key]);
    }
  }

  for (var _key in ALLEVENTS) {
    if (ALLEVENTS.hasOwnProperty(_key)) {
      HlsAllowedEvents.push(ALLEVENTS[_key]);
    }
  }

  var EVENTS = {
    ALLEVENTS: ALLEVENTS,
    HLS_EVENTS: HLS_EVENTS,
    REMUX_EVENTS: REMUX_EVENTS,
    DEMUX_EVENTS: DEMUX_EVENTS,
    MSE_EVENTS: MSE_EVENTS,
    LOADER_EVENTS: LOADER_EVENTS,
    FlvAllowedEvents: FlvAllowedEvents,
    HlsAllowedEvents: HlsAllowedEvents,
    CRYTO_EVENTS: CRYTO_EVENTS,
    PLAYER_EVENTS: PLAYER_EVENTS,
    BROWSER_EVENTS: BROWSER_EVENTS
  };

  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var LOADER_EVENTS$1 = EVENTS.LOADER_EVENTS;
  var READ_STREAM = 0;
  var READ_TEXT = 1;
  var READ_JSON = 2;
  var READ_BUFFER = 3;

  var FetchLoader = function () {
    function FetchLoader(configs) {
      _classCallCheck(this, FetchLoader);

      this.configs = Object.assign({}, configs);
      this.url = null;
      this.status = 0;
      this.error = null;
      this._reader = null;
      this._canceled = false;
      this._destroyed = false;
      this.readtype = this.configs.readtype;
      this.retryTime = this.configs.retryTime === undefined ? 3 : this.configs.retryTime;
      this.buffer = this.configs.buffer || 'LOADER_BUFFER';
      this._loaderTaskNo = 0;
    }

    _createClass(FetchLoader, [{
      key: 'init',
      value: function init() {
        this.on(LOADER_EVENTS$1.LADER_START, this.load.bind(this));
      }
    }, {
      key: 'fetch',
      value: function (_fetch) {
        function fetch(_x, _x2) {
          return _fetch.apply(this, arguments);
        }

        fetch.toString = function () {
          return _fetch.toString();
        };

        return fetch;
      }(function (url, params) {
        var timer = null;
        return Promise.race([fetch(url, params), new Promise(function (resolve, reject) {
          timer = setTimeout(function () {
            reject(new Error('fetch timeout'));
          }, 1e4); // 10s
        })]).then(function (response) {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          return response;
        });
      })
    }, {
      key: 'internalLoad',
      value: function internalLoad(url, params, retryTime) {
        var _this2 = this;

        return this.fetch(this.url, params).then(function (response) {
          if (response.ok) {
            _this2.emit(LOADER_EVENTS$1.LOADER_RESPONSE_HEADERS, _this2.TAG, response.headers);
            _this2.status = response.status;
            Promise.resolve().then(function () {
              _this2._onFetchResponse(response);
            });

            return Promise.resolve(response);
          }
          _this2.loading = false;
          if (retryTime-- > 0) {
            _this2.internalLoad(url, params, retryTime);
          } else {
            _this2.emit(LOADER_EVENTS$1.LOADER_ERROR, _this2.TAG, new Error(response.status + ' (' + response.statusText + ')'));
          }
        }).catch(function (error) {
          _this2.loading = false;
          if (retryTime-- > 0) {
            _this2.internalLoad(url, params, retryTime);
          } else {
            _this2.emit(LOADER_EVENTS$1.LOADER_ERROR, _this2.TAG, error);
            throw error;
          }
        });
      }
    }, {
      key: 'load',
      value: function load(url, opts) {
        this.url = url;

        this._canceled = false;

        // TODO: Add Ranges
        var params = this.getParams(opts);
        this.loading = true;
        this.internalLoad(url, params, this.retryTime);
      }
    }, {
      key: '_onFetchResponse',
      value: function _onFetchResponse(response) {
        var _this = this;
        var buffer = this._context.getInstance(this.buffer);
        this._loaderTaskNo++;
        var taskno = this._loaderTaskNo;
        if (response.ok === true) {
          switch (this.readtype) {
            case READ_JSON:
              response.json().then(function (data) {
                _this.loading = false;
                if (!_this._canceled && !_this._destroyed) {
                  if (buffer) {
                    buffer.push(data);
                    _this.emit(LOADER_EVENTS$1.LOADER_COMPLETE, buffer);
                  } else {
                    _this.emit(LOADER_EVENTS$1.LOADER_COMPLETE, data);
                  }
                }
              });
              break;
            case READ_TEXT:
              response.text().then(function (data) {
                _this.loading = false;
                if (!_this._canceled && !_this._destroyed) {
                  if (buffer) {
                    buffer.push(data);
                    _this.emit(LOADER_EVENTS$1.LOADER_COMPLETE, buffer);
                  } else {
                    _this.emit(LOADER_EVENTS$1.LOADER_COMPLETE, data);
                  }
                }
              });
              break;
            case READ_BUFFER:
              response.arrayBuffer().then(function (data) {
                _this.loading = false;
                if (!_this._canceled && !_this._destroyed) {
                  if (buffer) {
                    buffer.push(new Uint8Array(data));
                    _this.emit(LOADER_EVENTS$1.LOADER_COMPLETE, buffer);
                  } else {
                    _this.emit(LOADER_EVENTS$1.LOADER_COMPLETE, data);
                  }
                }
              });
              break;
            case READ_STREAM:
            default:
              return this._onReader(response.body.getReader(), taskno);
          }
        }
      }
    }, {
      key: '_onReader',
      value: function _onReader(reader, taskno) {
        var _this3 = this;

        var buffer = this._context.getInstance(this.buffer);
        if (!buffer && this._reader || this._destroyed) {
          try {
            this._reader.cancel();
          } catch (e) {
            // DO NOTHING
          }
        }

        this._reader = reader;
        if (this.loading === false) {
          return;
        }

        // reader read function returns a Promise. get data when callback and has value.done when disconnected.
        // read方法返回一个Promise. 回调中可以获取到数据。当value.done存在时，说明链接断开。
        this._reader && this._reader.read().then(function (val) {
          if (_this3._canceled || _this3._destroyed) {
            if (_this3._reader) {
              try {
                _this3._reader.cancel();
              } catch (e) {
                // DO NOTHING
              }
            }
            return;
          }
          if (val.done) {
            _this3.loading = false;
            _this3.status = 0;
            Promise.resolve().then(function () {
              _this3.emit(LOADER_EVENTS$1.LOADER_COMPLETE, buffer);
            });
            return;
          }

          buffer.push(val.value);
          Promise.resolve().then(function () {
            _this3.emit(LOADER_EVENTS$1.LOADER_DATALOADED, buffer);
          });
          return _this3._onReader(reader, taskno);
        }).catch(function (error) {
          _this3.loading = false;
          _this3.emit(LOADER_EVENTS$1.LOADER_ERROR, _this3.TAG, error);
          throw error;
        });
      }
    }, {
      key: 'getParams',
      value: function getParams(opts) {
        var options = Object.assign({}, opts);
        var headers = new Headers();

        var params = {
          method: 'GET',
          headers: headers,
          mode: 'cors',
          cache: 'default'

          // add custmor headers
          // 添加自定义头
        };if (_typeof(this.configs.headers) === 'object') {
          var configHeaders = this.configs.headers;
          for (var key in configHeaders) {
            if (configHeaders.hasOwnProperty(key)) {
              headers.append(key, configHeaders[key]);
            }
          }
        }

        if (_typeof(options.headers) === 'object') {
          var optHeaders = options.headers;
          for (var _key in optHeaders) {
            if (optHeaders.hasOwnProperty(_key)) {
              headers.append(_key, optHeaders[_key]);
            }
          }
        }

        if (options.cors === false) {
          params.mode = 'same-origin';
        }

        // withCredentials is disabled by default
        // withCredentials 在默认情况下不被使用。
        if (options.withCredentials) {
          params.credentials = 'include';
        }

        // TODO: Add ranges;
        return params;
      }
    }, {
      key: 'cancel',
      value: function cancel() {
        if (this._reader) {
          try {
            this._reader.cancel();
          } catch (e) {
            // 防止failed: 200错误被打印到控制台上
          }
          this._reader = null;
          this.loading = false;
        }
        this._canceled = true;
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this._destroyed = true;
        this.cancel();
      }
    }], [{
      key: 'type',
      get: function get() {
        return 'loader';
      }
    }]);

    return FetchLoader;
  }();

  var _typeof2$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _typeof$1 = typeof Symbol === "function" && _typeof2$1(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : _typeof2$1(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2$1(obj);
  };

  var _createClass$1 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var DEMUX_EVENTS$1 = EVENTS.DEMUX_EVENTS;
  var StreamType = {
    0x01: ['video', 'MPEG-1'],
    0x02: ['video', 'MPEG-2'],
    0x1b: ['video', 'AVC.H264'],
    0x24: ['video', 'HVC.H265'],
    0xea: ['video', 'VC-1'],
    0x03: ['audio', 'MPEG-1'],
    0x04: ['audio', 'MPEG-2'],
    0x0f: ['audio', 'MPEG-2.AAC'],
    0x11: ['audio', 'MPEG-4.AAC'],
    0x80: ['audio', 'LPCM'],
    0x81: ['audio', 'AC3'],
    0x06: ['audio', 'AC3'],
    0x82: ['audio', 'DTS'],
    0x83: ['audio', 'Dolby TrueHD'],
    0x84: ['audio', 'AC3-Plus'],
    0x85: ['audio', 'DTS-HD'],
    0x86: ['audio', 'DTS-MA'],
    0xa1: ['audio', 'AC3-Plus-SEC'],
    0xa2: ['audio', 'DTS-HD-SEC']
  };

  var TsDemuxer = function () {
    function TsDemuxer(configs) {
      _classCallCheck$1(this, TsDemuxer);

      this.configs = Object.assign({}, configs);
      this.demuxing = false;
      this.pat = [];
      this.pmt = [];
      this._hasVideoMeta = false;
      this._hasAudioMeta = false;
    }

    _createClass$1(TsDemuxer, [{
      key: 'init',
      value: function init() {
        this.on(DEMUX_EVENTS$1.DEMUX_START, this.demux.bind(this));
      }
    }, {
      key: 'demux',
      value: function demux(frag) {
        var _this = this;

        if (this.demuxing) {
          return;
        }

        var buffer = this.inputBuffer;
        var frags = { pat: [], pmt: [] };
        var peses = {};

        Promise.resolve().then(function () {
          // Read TS segment
          while (buffer.length >= 188) {
            if (buffer.length >= 1 && buffer.array[0][buffer.offset] !== 71) {
              _this.emit(DEMUX_EVENTS$1.DEMUX_ERROR, _this.TAG, new Error('Untrust sync code: ' + buffer.array[0][buffer.offset] + ', try to recover;'), false);
            }
            while (buffer.length >= 1 && buffer.array[0][buffer.offset] !== 71) {
              buffer.shift(1);
            }
            if (buffer.length < 188) {
              continue;
            }
            var buf = buffer.shift(188);
            // console.log(buf);
            var tsStream = new Stream(buf.buffer);
            var ts = {};
            TsDemuxer.read(tsStream, ts, frags);
            var pes = peses[ts.header.pid];
            if (ts.pes) {
              ts.pes.codec = ts.header.codec;
              if (!peses[ts.header.pid]) {
                peses[ts.header.pid] = [];
              }
              peses[ts.header.pid].push(ts.pes);
              ts.pes.ES.buffer = [ts.pes.ES.buffer];
            } else if (pes) {
              pes[pes.length - 1].ES.buffer.push(ts.payload.stream);
            }
          }
        });

        setTimeout(function () {
          var AudioOptions = Object.assign({}, frag);
          var VideoOptions = Object.assign({}, frag);

          // Get Frames data
          for (var i = 0; i < Object.keys(peses).length; i++) {
            var epeses = peses[Object.keys(peses)[i]];
            for (var j = 0; j < epeses.length; j++) {
              epeses[j].id = Object.keys(peses)[i];

              if (epeses[j].type === 'audio') {
                epeses[j].ES.buffer = TsDemuxer.mergeAudioES(epeses[j].ES.buffer);
                _this.pushAudioSample(epeses[j], AudioOptions);
                AudioOptions = {};
              } else if (epeses[j].type === 'video') {
                epeses[j].ES.buffer = TsDemuxer.mergeVideoES(epeses[j].ES.buffer);
                if (epeses[j].codec === 'HVC.H265') {
                  _this.pushVideoSampleHEVC(epeses[j], VideoOptions);
                } else {
                  _this.pushVideoSample(epeses[j], VideoOptions);
                }
                VideoOptions = {};
              }
            }
          }
        });
        setTimeout(function () {
          if (_this._hasAudioMeta) {
            _this.emit(DEMUX_EVENTS$1.DEMUX_COMPLETE, 'audio');
          }
          if (_this._hasVideoMeta) {
            _this.emit(DEMUX_EVENTS$1.DEMUX_COMPLETE, 'video');
          }
        });
      }
    }, {
      key: 'pushAudioSample',
      value: function pushAudioSample(pes, options) {
        var _track$samples;

        var track = void 0;
        if (!this._tracks || !this._tracks.audioTrack) {
          this._tracks.audioTrack = new Tracks.AudioTrack();
          track = this._tracks.audioTrack;
        } else {
          track = this._tracks.audioTrack;
        }
        var meta = new xgplayerTransmuxerModelTrackmeta.AudioTrackMeta({
          audioSampleRate: pes.ES.frequence,
          sampleRate: pes.ES.frequence,
          channelCount: pes.ES.channel,
          codec: 'mp4a.40.' + pes.ES.audioObjectType,
          objectType: pes.ES.audioObjectType,
          originCodec: 'mp4a.40.' + pes.ES.originAudioObjectType,
          config: pes.ES.audioConfig,
          id: 2,
          sampleRateIndex: pes.ES.frequencyIndex
        });
        meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);

        var metaEqual = TsDemuxer.compaireMeta(track.meta, meta, true);

        if (!this._hasAudioMeta || !metaEqual) {
          track.meta = meta;
          this._hasAudioMeta = true;
          if (options) {
            options.meta = Object.assign({}, meta);
          } else {
            options = {
              meta: Object.assign({}, meta)
            };
          }
          this.emit(DEMUX_EVENTS$1.METADATA_PARSED, 'audio');
        }

        var frameIndex = 0;
        var samples = [];

        pes.ES.buffer.skip(pes.pesHeaderLength + 9);
        var streamChanged = false;
        while (pes.ES.buffer.position < pes.ES.buffer.length) {
          if (xgplayerTransmuxerCodecAac.ADTS.isHeader(new Uint8Array(pes.ES.buffer.buffer), pes.ES.buffer.position) && pes.ES.buffer.position + 5 < pes.ES.buffer.length) {
            var frame = xgplayerTransmuxerCodecAac.ADTS.appendFrame(track, new Uint8Array(pes.ES.buffer.buffer), pes.ES.buffer.position, pes.pts, frameIndex);
            if (frame && frame.sample) {
              // logger.log(`${Math.round(frame.sample.pts)} : AAC`);
              pes.ES.buffer.skip(frame.length);
              var sample = new xgplayerTransmuxerModelTracksample.AudioTrackSample({
                dts: frame.sample.dts,
                pts: frame.sample.pts,
                data: frame.sample.unit,
                options: streamChanged ? {} : options
              });
              if (options.meta) {
                streamChanged = true;
              }
              samples.push(sample);
              frameIndex++;
            } else {
              // logger.log('Unable to parse AAC frame');
              break;
            }
          } else {
            // nothing found, keep looking
            pes.ES.buffer.skip(1);
          }
        }
        for (var i = 0; i < samples.length; i++) {
          var _sample = samples[i];
          _sample.dts = _sample.pts = Math.ceil(_sample.pts / 90);
        }

        // let data = new Uint8Array(pes.ES.buffer.buffer.slice(pes.ES.buffer.position, pes.ES.buffer.length));
        // let sample = new AudioTrackSample({dts, pts, data, options});
        (_track$samples = track.samples).push.apply(_track$samples, samples);
      }
    }, {
      key: 'pushVideoSample',
      value: function pushVideoSample(pes, options) {
        var nals = xgplayerTransmuxerCodecAvc.NalUnit.getNalunits(pes.ES.buffer);
        var track = void 0;
        var meta = new xgplayerTransmuxerModelTrackmeta.VideoTrackMeta();
        if (!this._tracks || !this._tracks.videoTrack) {
          this._tracks.videoTrack = new Tracks.VideoTrack();
          track = this._tracks.videoTrack;
        } else {
          track = this._tracks.videoTrack;
        }
        var sampleLength = 0;
        var sps = false;
        var pps = false;
        var sei = null;
        for (var i = 0; i < nals.length; i++) {
          var nal = nals[i];
          if (nal.sps) {
            sps = nal;
            track.sps = nal.body;
            meta.sps = nal.body;
            meta.chromaFormat = sps.sps.chroma_format;
            meta.codec = 'avc1.';
            for (var j = 1; j < 4; j++) {
              var h = sps.body[j].toString(16);
              if (h.length < 2) {
                h = '0' + h;
              }
              meta.codec += h;
            }
            meta.codecHeight = sps.sps.codec_size.height;
            meta.codecWidth = sps.sps.codec_size.width;
            meta.frameRate = sps.sps.frame_rate;
            meta.id = 1;
            meta.level = sps.sps.level_string;
            meta.presentHeight = sps.sps.present_size.height;
            meta.presentWidth = sps.sps.present_size.width;
            meta.profile = sps.sps.profile_string;
            meta.refSampleDuration = Math.floor(meta.timescale * (sps.sps.frame_rate.fps_den / sps.sps.frame_rate.fps_num));
            meta.sarRatio = sps.sps.sar_ratio ? sps.sps.sar_ratio : sps.sps.par_ratio;
          } else if (nal.pps) {
            track.pps = nal.body;
            meta.pps = nal.body;
            pps = nal;
          } else if (nal.sei) {
            sei = nal.sei;
          } else if (nal.type < 9) {
            sampleLength += 4 + nal.body.byteLength;
          }
        }

        if (sps && pps) {
          meta.avcc = xgplayerTransmuxerCodecAvc.NalUnit.getAvcc(sps.body, pps.body);
          var metaEqual = TsDemuxer.compaireMeta(track.meta, meta, true);
          if (!this._hasVideoMeta || !metaEqual) {
            if (options) {
              options.meta = Object.assign({}, meta);
            } else {
              options = {
                meta: Object.assign({}, meta)
              };
            }
            track.meta = meta;
            this._hasVideoMeta = true;
            this.emit(DEMUX_EVENTS$1.METADATA_PARSED, 'video');
          }
        }

        var data = new Uint8Array(sampleLength);
        var offset = 0;
        var isKeyframe = false;
        for (var _i = 0; _i < nals.length; _i++) {
          var _nal = nals[_i];
          if (_nal.type && _nal.type >= 9) {
            continue;
          }
          var length = _nal.body.byteLength;
          if (_nal.idr) {
            isKeyframe = true;
          }
          if (!_nal.pps && !_nal.sps && !_nal.sei) {
            data.set(new Uint8Array([length >>> 24 & 0xff, length >>> 16 & 0xff, length >>> 8 & 0xff, length & 0xff]), offset);
            offset += 4;
            data.set(_nal.body, offset);
            offset += length;
          }
        }
        var dts = parseInt(pes.dts / 90);
        var pts = parseInt(pes.pts / 90);

        if (sei) {
          sei.dts = dts;
          this.emit(DEMUX_EVENTS$1.SEI_PARSED, sei);
        }
        var sample = new xgplayerTransmuxerModelTracksample.VideoTrackSample({
          dts: dts,
          pts: pts,
          cts: pts - dts,
          originDts: pes.dts,
          isKeyframe: isKeyframe,
          data: data,
          options: options
        });
        track.samples.push(sample);
      }
    }, {
      key: 'pushVideoSampleHEVC',
      value: function pushVideoSampleHEVC(pes, options) {
        var nals = xgplayerTransmuxerCodecHevc.NalUnitHEVC.getNalunits(pes.ES.buffer);
        var track = void 0;
        var meta = new xgplayerTransmuxerModelTrackmeta.VideoTrackMeta();
        meta.streamType = 0x24;
        if (!this._tracks.videoTrack) {
          this._tracks.videoTrack = new Tracks.VideoTrack();
          track = this._tracks.videoTrack;
        } else {
          track = this._tracks.videoTrack;
        }

        var sampleLength = 0;
        var vps = false;
        var sps = false;
        var pps = false;
        var sei = null;
        var hasVPS = false;
        var hasSPS = false;
        var hasPPS = false;
        var hasKeyframe = false;
        for (var i = 0; i < nals.length; i++) {
          var nal = nals[i];

          if (nal.vps) {
            if (hasVPS) {
              continue;
            } else {
              hasVPS = true;
            }
          } else if (nal.sps) {
            if (hasSPS) {
              continue;
            } else {
              hasSPS = true;
            }
          } else if (nal.pps) {
            if (hasPPS) {
              continue;
            } else {
              hasPPS = true;
            }
          } else if (nal.key) {
            hasKeyframe = true;
          } else if (nal.type === 0) {
            if (!hasKeyframe) {
              continue;
            }
          } else if (nal.type === 35) {
            continue;
          }
          if (nal.sps) {
            sps = nal;
            track.sps = nal.body;
            // meta.chromaFormat = sps.sps.chroma_format
            // meta.codec = 'hvc1.';
            // for (var j = 1; j < 4; j++) {
            //   var h = sps.body[j].toString(16);
            //   if (h.length < 2) {
            //     h = '0' + h;
            //   }
            //   meta.codec += h;
            // }
            // meta.codecHeight = sps.sps.codec_size.height;
            // meta.codecWidth = sps.sps.codec_size.width;
            // meta.frameRate = sps.sps.frame_rate;
            // meta.id = 1;
            // meta.level = sps.sps.level_string;
            // meta.presentHeight = sps.sps.present_size.height;
            // meta.presentWidth = sps.sps.present_size.width;
            // meta.profile = sps.sps.profile_string;
            // meta.refSampleDuration = Math.floor(meta.timescale * (sps.sps.frame_rate.fps_den / sps.sps.frame_rate.fps_num));
            // meta.sarRatio = sps.sps.sar_ratio ? sps.sps.sar_ratio : sps.sps.par_ratio;

            meta.presentWidth = sps.sps.width;
            meta.presentHeight = sps.sps.height;
            meta.general_profile_space = sps.sps.general_profile_space;
            meta.general_tier_flag = sps.sps.general_tier_flag;
            meta.general_profile_idc = sps.sps.general_profile_idc;
            meta.general_level_idc = sps.sps.general_level_idc;
            // meta.duration = this._duration;
            meta.codec = 'hev1.1.6.L93.B0';
            meta.chromaFormatIdc = sps.sps.chromaFormatIdc;
            meta.bitDepthLumaMinus8 = sps.sps.bitDepthLumaMinus8;
            meta.bitDepthChromaMinus8 = sps.sps.bitDepthChromaMinus8;
          } else if (nal.pps) {
            track.pps = nal.body;
            pps = nal;
          } else if (nal.vps) {
            track.vps = nal.body;
            vps = nal;
          } else if (nal.sei) {
            sei = nal.sei;
          }
          if (nal.type <= 40) {
            sampleLength += 4 + nal.body.byteLength;
          }
        }

        if (sps && pps && vps) {
          // meta.avcc = NalUnitHEVC.getAvcc(sps.body, pps.body);
          var metaEqual = TsDemuxer.compaireMeta(track.meta, meta, true);
          if (!this._hasVideoMeta || !metaEqual) {
            if (options) {
              options.meta = Object.assign({}, meta);
            } else {
              options = {
                meta: Object.assign({}, meta)
              };
            }
            meta.streamType = 0x24;
            this._tracks.videoTrack.meta = meta;
            this._hasVideoMeta = true;
            this.emit(DEMUX_EVENTS$1.METADATA_PARSED, 'video');
          }
        }

        var data = new Uint8Array(sampleLength);
        var offset = 0;
        var isKeyframe = false;
        hasVPS = false;
        hasSPS = false;
        hasPPS = false;
        hasKeyframe = false;
        for (var _i2 = 0; _i2 < nals.length; _i2++) {
          var _nal2 = nals[_i2];
          if (_nal2.type && _nal2.type > 40) {
            continue;
          }

          if (_nal2.vps) {
            if (hasVPS) {
              continue;
            } else {
              hasVPS = true;
            }
          } else if (_nal2.sps) {
            if (hasSPS) {
              continue;
            } else {
              hasSPS = true;
            }
          } else if (_nal2.pps) {
            if (hasPPS) {
              continue;
            } else {
              hasPPS = true;
            }
          } else if (_nal2.key) {
            hasKeyframe = true;
          } else if (_nal2.type === 0) {
            if (!hasKeyframe) {
              continue;
            }
          } else if (_nal2.type === 35) {
            continue;
          }
          var length = _nal2.body.byteLength;
          if (_nal2.key) {
            isKeyframe = true;
          }
          // if (!nal.vps && !nal.pps && !nal.sps) {
          data.set(new Uint8Array([length >>> 24 & 0xff, length >>> 16 & 0xff, length >>> 8 & 0xff, length & 0xff]), offset);
          offset += 4;
          data.set(_nal2.body, offset);
          offset += length;
          // }
        }
        var dts = parseInt(pes.dts / 90);
        var pts = parseInt(pes.pts / 90);

        if (sei) {
          sei.dts = dts;
          this.emit(DEMUX_EVENTS$1.SEI_PARSED, sei);
        }

        var sample = new xgplayerTransmuxerModelTracksample.VideoTrackSample({
          dts: dts,
          pts: pts,
          cts: pts - dts,
          originDts: pes.dts,
          isKeyframe: isKeyframe,
          data: data,
          options: options
        });
        track.samples.push(sample);
      }
    }, {
      key: 'destory',
      value: function destory() {
        this.off(DEMUX_EVENTS$1.DEMUX_START, this.demux);
        this.configs = {};
        this.demuxing = false;
        this.pat = [];
        this.pmt = [];
        this._hasVideoMeta = false;
        this._hasAudioMeta = false;
      }
    }, {
      key: 'inputBuffer',
      get: function get() {
        return this._context.getInstance(this.configs.inputbuffer);
      }
    }, {
      key: '_tracks',
      get: function get() {
        return this._context.getInstance('TRACKS');
      }
    }], [{
      key: 'compaireArray',
      value: function compaireArray(a, b, type) {
        var al = 0;
        var bl = 0;
        if (type === 'Uint8Array') {
          al = a.byteLength;
          bl = b.byteLength;
        } else if (type === 'Array') {
          al = a.length;
          bl = b.length;
        }
        if (al !== bl) {
          return false;
        }

        for (var i = 0; i < al; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: 'compaireMeta',
      value: function compaireMeta(a, b, ignoreDuration) {
        if (!a || !b) {
          return false;
        }

        for (var i = 0, k = Object.keys(a).length; i < k; i++) {
          var itema = a[Object.keys(a)[i]];
          var itemb = b[Object.keys(a)[i]];
          if (!itema && !itemb) {
            return true;
          }

          if (itema === undefined && itemb || itema && itemb === undefined) {
            return false;
          }

          if ((typeof itema === 'undefined' ? 'undefined' : _typeof$1(itema)) !== 'object') {
            if (ignoreDuration && Object.keys(a)[i] !== 'duration' && Object.keys(a)[i] !== 'refSampleDuration' && Object.keys(a)[i] !== 'refSampleDurationFixed' && itema !== itemb) {
              return false;
            }
          } else if (itema.byteLength !== undefined) {
            if (itemb.byteLength === undefined) {
              return false;
            }
            if (!TsDemuxer.compaireArray(itema, itemb, 'Uint8Array')) {
              return false;
            }
          } else if (itema.length !== undefined) {
            if (itemb.length === undefined) {
              return false;
            }
            if (!TsDemuxer.compaireArray(itema, itemb, 'Array')) {
              return false;
            }
          } else {
            if (!TsDemuxer.compaireMeta(itema, itemb)) {
              return false;
            }
          }
        }
        return true;
      }
    }, {
      key: 'mergeVideoES',
      value: function mergeVideoES(buffers) {
        var data = void 0;
        var length = 0;
        var offset = 0;
        for (var i = 0; i < buffers.length; i++) {
          length += buffers[i].length - buffers[i].position;
        }

        data = new Uint8Array(length);
        for (var _i3 = 0; _i3 < buffers.length; _i3++) {
          var buffer = buffers[_i3];
          data.set(new Uint8Array(buffer.buffer, buffer.position), offset);
          offset += buffer.length - buffer.position;
        }
        return new Stream(data.buffer);
      }
    }, {
      key: 'mergeAudioES',
      value: function mergeAudioES(buffers) {
        var data = void 0;
        var length = 0;
        var offset = 0;
        for (var i = 0; i < buffers.length; i++) {
          length += buffers[i].length;
        }

        data = new Uint8Array(length);
        for (var _i4 = 0; _i4 < buffers.length; _i4++) {
          var buffer = buffers[_i4];
          data.set(new Uint8Array(buffer.buffer), offset);
          offset += buffer.length;
        }

        return new Stream(data.buffer);
      }
    }, {
      key: 'read',
      value: function read(stream, ts, frags) {
        TsDemuxer.readHeader(stream, ts);
        TsDemuxer.readPayload(stream, ts, frags);
        if (ts.header.packet === 'MEDIA' && ts.header.payload === 1 && !ts.unknownPIDs) {
          ts.pes = TsDemuxer.PES(ts);
        }
      }
    }, {
      key: 'readPayload',
      value: function readPayload(stream, ts, frags) {
        var header = ts.header;
        var pid = header.pid;
        switch (pid) {
          case 0:
            TsDemuxer.PAT(stream, ts, frags);
            break;
          case 1:
            TsDemuxer.CAT(stream, ts, frags);
            break;
          case 2:
            TsDemuxer.TSDT(stream, ts, frags);
            break;
          case 0x1fff:
            break;
          default:
            // TODO: some的写法不太好，得改
            if (frags.pat.some(function (item) {
              return item.pid === pid;
            })) {
              TsDemuxer.PMT(stream, ts, frags);
            } else {
              var sts = frags.pmt ? frags.pmt.filter(function (item) {
                return item.pid === pid;
              }) : [];
              if (sts.length > 0) {
                TsDemuxer.Media(stream, ts, StreamType[sts[0].streamType][0]);
                ts.header.codec = StreamType[sts[0].streamType][1];
              } else {
                ts.unknownPIDs = true;
              }
            }
        }
      }
    }, {
      key: 'readHeader',
      value: function readHeader(stream, ts) {
        var header = {};
        header.sync = stream.readUint8();
        var next = stream.readUint16();
        header.error = next >>> 15;
        header.payload = next >>> 14 & 1;
        header.priority = next >>> 13 & 1;
        header.pid = next & 0x1fff;

        next = stream.readUint8();

        header.scrambling = next >> 6 & 0x3; // 是否加密，00表示不加密

        /**
         * 00 ISO/IEC未来使用保留
         * 01 没有调整字段，仅含有184B有效净荷
         * 02 没有有效净荷，仅含有183B调整字段
         * 03 0~182B调整字段后为有效净荷
         */
        header.adaptation = next >> 4 & 0x3;
        header.continuity = next & 15;
        header.packet = header.pid === 0 ? 'PAT' : 'MEDIA';
        ts.header = header;
      }
    }, {
      key: 'PAT',
      value: function PAT(stream, ts, frags) {
        var ret = {};
        var next = stream.readUint8();
        stream.skip(next);
        next = stream.readUint8();
        ret.tabelID = next;
        next = stream.readUint16();
        ret.error = next >>> 7;
        ret.zero = next >>> 6 & 1;
        ret.sectionLength = next & 0xfff;
        ret.streamID = stream.readUint16();
        ret.current = stream.readUint8() & 1;
        ret.sectionNumber = stream.readUint8();
        ret.lastSectionNumber = stream.readUint8();
        var N = (ret.sectionLength - 9) / 4;
        var list = [];
        for (var i = 0; i < N; i++) {
          var programNumber = stream.readUint16();
          var pid = stream.readUint16() & 0x1fff;
          list.push({
            program: programNumber,
            pid: pid,
            type: programNumber === 0 ? 'network' : 'mapPID'
          });
        }
        if (list.length > 0) {
          frags.pat = frags.pat.concat(list);
        }
        ret.list = list;
        ret.program = stream.readUint16();
        ret.pid = stream.readUint16() & 0x1fff;
        ts.payload = ret;
        // TODO CRC
      }
    }, {
      key: 'PMT',
      value: function PMT(stream, ts, frags) {
        var ret = {};
        var header = ts.header;
        header.packet = 'PMT';
        var next = stream.readUint8();
        stream.skip(next);
        next = stream.readUint8();
        ret.tableID = next;
        next = stream.readUint16();
        ret.sectionLength = next & 0xfff;
        ret.program = stream.readUint16();
        ret.current = stream.readUint8() & 1;
        ret.order = stream.readUint8();
        ret.lastOrder = stream.readUint8();
        ret.PCR_PID = stream.readUint16() & 0x1fff;
        ret.programLength = stream.readUint16() & 0xfff;
        var N = (ret.sectionLength - 13) / 5;
        var list = [];
        for (var i = 0; i < N; i++) {
          list.push({
            streamType: stream.readUint8(),
            pid: stream.readUint16() & 0x1fff, // 0x07e5 视频，0x07e6
            es: stream.readUint16() & 0xfff
          });
        }
        ret.list = list;
        if (!this.pmt) {
          this.pmt = [];
        }
        frags.pmt = this.pmt.concat(list.map(function (item) {
          return {
            pid: item.pid,
            es: item.es,
            streamType: item.streamType,
            program: ret.program
          };
        }));
        ts.payload = ret;
      }
    }, {
      key: 'Media',
      value: function Media(stream, ts, type) {
        var header = ts.header;
        var payload = {};
        header.type = type;
        if (header.adaptation === 0x03) {
          payload.adaptationLength = stream.readUint8();
          if (payload.adaptationLength > 0) {
            var next = stream.readUint8();
            payload.discontinue = next >>> 7;
            payload.access = next >>> 6 & 0x01;
            payload.priority = next >>> 5 & 0x01;
            payload.PCR = next >>> 4 & 0x01;
            payload.OPCR = next >>> 3 & 0x01;
            payload.splicePoint = next >>> 2 & 0x01;
            payload.transportPrivate = next >>> 1 & 0x01;
            payload.adaptationField = next & 0x01;
            var _start = stream.position;
            if (payload.PCR === 1) {
              payload.programClockBase = stream.readUint32() << 1;
              next = stream.readUint16();
              payload.programClockBase |= next >>> 15;
              payload.programClockExtension = next & 0x1ff;
            }
            if (payload.OPCR === 1) {
              payload.originProgramClockBase = stream.readUint32() << 1;
              next = stream.readUint16();
              payload.originProgramClockBase += next >>> 15;
              payload.originProgramClockExtension = next & 0x1ff;
            }
            if (payload.splicePoint === 1) {
              payload.spliceCountdown = stream.readUint8();
            }
            if (payload.transportPrivate === 1) {
              var length = stream.readUint8();
              var transportPrivateData = [];
              for (var i = 0; i < length; i++) {
                transportPrivateData.push(stream.readUint8());
              }
            }
            if (payload.adaptationField === 1) {
              var _length = stream.readUint8();
              var _next = stream.readUint8();
              var start = stream.position;
              var ltw = _next >>> 7;
              var piecewise = _next >>> 6 & 0x1;
              var seamless = _next >>> 5 & 0x1;
              if (ltw === 1) {
                _next = stream.readUint16();
                payload.ltwValid = _next >>> 15;
                payload.ltwOffset = _next & 0xefff;
              }
              if (piecewise === 1) {
                _next = stream.readUint24();
                payload.piecewiseRate = _next & 0x3fffff;
              }
              if (seamless === 1) {
                _next = stream.readInt8();
                payload.spliceType = _next >>> 4;
                payload.dtsNextAU1 = _next >>> 1 & 0x7;
                payload.marker1 = _next & 0x1;
                _next = stream.readUint16();
                payload.dtsNextAU2 = _next >>> 1;
                payload.marker2 = _next & 0x1;
                _next = stream.readUint16();
                payload.dtsNextAU3 = _next;
              }
              stream.skip(_length - 1 - (stream.position - start));
            }
            var lastStuffing = payload.adaptationLength - 1 - (stream.position - _start);
            stream.skip(lastStuffing);
          }
        }
        payload.stream = new Stream(stream.buffer.slice(stream.position));
        ts.payload = payload;
      }
    }, {
      key: 'PES',
      value: function PES(ts) {
        var ret = {};
        var buffer = ts.payload.stream;

        var next = buffer.readUint24();
        if (next !== 1) {
          ret.ES = {};
          ret.ES.buffer = buffer;
        } else {
          var streamID = buffer.readUint8();
          if (streamID >= 0xe0 && streamID <= 0xef) {
            ret.type = 'video';
          }
          if (streamID >= 0xc0 && streamID <= 0xdf) {
            ret.type = 'audio';
          }
          var packetLength = buffer.readUint16();
          ret.packetLength = packetLength;
          if (ret.type === 'video' || ret.type === 'audio') {
            var _next2 = buffer.readUint8();
            var first = _next2 >>> 6;
            if (first !== 0x02) {
              throw new Error('error when parse pes header');
            }
            _next2 = buffer.readUint8();
            ret.ptsDTSFlag = _next2 >>> 6;
            ret.escrFlag = _next2 >>> 5 & 0x01;
            ret.esRateFlag = _next2 >>> 4 & 0x01;
            ret.dsmFlag = _next2 >>> 3 & 0x01;
            ret.additionalFlag = _next2 >>> 2 & 0x01;
            ret.crcFlag = _next2 >>> 1 & 0x01;
            ret.extensionFlag = _next2 & 0x01;
            ret.pesHeaderLength = buffer.readUint8();
            var N1 = ret.pesHeaderLength;

            if (ret.ptsDTSFlag === 2) {
              var pts = [];
              _next2 = buffer.readUint8();
              pts.push(_next2 >>> 1 & 0x07);
              _next2 = buffer.readUint16();
              pts.push(_next2 >>> 1);
              _next2 = buffer.readUint16();
              pts.push(_next2 >>> 1);
              ret.pts = pts[0] << 30 | pts[1] << 15 | pts[2];
              N1 -= 5;
              // 视频如果没有dts用pts
              if (ret.type === 'video') {
                ret.dts = ret.pts;
              }
            }
            if (ret.ptsDTSFlag === 3) {
              var _pts = [];
              _next2 = buffer.readUint8();
              _pts.push(_next2 >>> 1 & 0x07);
              _next2 = buffer.readUint16();
              _pts.push(_next2 >>> 1);
              _next2 = buffer.readUint16();
              _pts.push(_next2 >>> 1);
              ret.pts = _pts[0] << 30 | _pts[1] << 15 | _pts[2];
              var dts = [];
              _next2 = buffer.readUint8();
              dts.push(_next2 >>> 1 & 0x07);
              _next2 = buffer.readUint16();
              dts.push(_next2 >>> 1);
              _next2 = buffer.readUint16();
              dts.push(_next2 >>> 1);
              ret.dts = dts[0] << 30 | dts[1] << 15 | dts[2];
              N1 -= 10;
            }
            if (ret.escrFlag === 1) {
              var escr = [];
              var ex = [];
              _next2 = buffer.readUint8();
              escr.push(_next2 >>> 3 & 0x07);
              escr.push(_next2 & 0x03);
              _next2 = buffer.readUint16();
              escr.push(_next2 >>> 13);
              escr.push(_next2 & 0x03);
              _next2 = buffer.readUint16();
              escr.push(_next2 >>> 13);
              ex.push(_next2 & 0x03);
              _next2 = buffer.readUint8();
              ex.push(_next2 >>> 1);
              ret.escr = (escr[0] << 30 | escr[1] << 28 | escr[2] << 15 | escr[3] << 13 | escr[4]) * 300 + (ex[0] << 7 | ex[1]);
              N1 -= 6;
            }
            if (ret.esRateFlag === 1) {
              _next2 = buffer.readUint24();
              ret.esRate = _next2 >>> 1 & 0x3fffff;
              N1 -= 3;
            }
            if (ret.dsmFlag === 1) {
              throw new Error('not support DSM_trick_mode');
            }
            if (ret.additionalFlag === 1) {
              _next2 = buffer.readUint8();
              ret.additionalCopyInfo = _next2 & 0x7f;
              N1 -= 1;
            }
            if (ret.crcFlag === 1) {
              ret.pesCRC = buffer.readUint16();
              N1 -= 2;
            }
            if (ret.extensionFlag === 1) {
              throw new Error('not support extension');
            }
            if (N1 > 0) {
              buffer.skip(N1);
            }
            ret.ES = TsDemuxer.ES(buffer, ret.type);
          } else {
            throw new Error('format is not supported');
          }
        }
        return ret;
      }
    }, {
      key: 'ES',
      value: function ES(buffer, type) {
        var next = void 0;
        var ret = {};
        if (type === 'video') {
          // next = buffer.readUint32();
          // if (next !== 1) {
          //   buffer.back(4);
          //   next = buffer.readUint24();
          //   if (next !== 1) {
          //     throw new Error('h264 nal header parse failed');
          //   }
          // }
          // buffer.skip(2);// 09 F0
          // TODO readnalu
          ret.buffer = buffer;
        } else if (type === 'audio') {
          next = buffer.readUint16();
          // adts的同步字节，12位
          if (next >>> 4 !== 0xfff) {
            throw new Error('aac ES parse Error');
          }
          var fq = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
          ret.id = (next >>> 3 & 0x01) === 0 ? 'MPEG-4' : 'MPEG-2';
          ret.layer = next >>> 1 & 0x03;
          ret.absent = next & 0x01;
          next = buffer.readUint16();
          ret.audioObjectType = (next >>> 14 & 0x03) + 1;
          ret.profile = ret.audioObjectType - 1;
          ret.frequencyIndex = next >>> 10 & 0x0f;
          ret.frequence = fq[ret.frequencyIndex];
          ret.channel = next >>> 6 & 0x07;
          ret.frameLength = (next & 0x03) << 11 | buffer.readUint16() >>> 5;
          TsDemuxer.getAudioConfig(ret);
          buffer.skip(1);
          ret.buffer = buffer;
        } else {
          throw new Error('ES ' + type + ' is not supported');
        }

        return ret;
      }
    }, {
      key: 'TSDT',
      value: function TSDT(stream, ts, frags) {
        // TODO
        ts.payload = {};
      }
    }, {
      key: 'CAT',
      value: function CAT(stream, ts, frags) {
        var ret = {};
        ret.tableID = stream.readUint8();
        var next = stream.readUint16();
        ret.sectionIndicator = next >>> 7;
        ret.sectionLength = next & 0x0fff;
        stream.skip(2);
        next = stream.readUint8();
        ret.version = next >>> 3;
        ret.currentNextIndicator = next & 0x01;
        ret.sectionNumber = stream.readUint8();
        ret.lastSectionNumber = stream.readUint8();
        var N = (this.sectionLength - 9) / 4;
        ret.crc32 = stream.readUint32();
        ts.payload = ret;
      }
    }, {
      key: 'getAudioConfig',
      value: function getAudioConfig(ret) {
        var userAgent = navigator.userAgent.toLowerCase();
        var config = void 0;
        var extensionSampleIndex = void 0;
        ret.originAudioObjectType = ret.audioObjectType;
        if (/firefox/i.test(userAgent)) {
          if (ret.frequencyIndex >= 6) {
            ret.audioObjectType = 5;
            config = new Array(4);
            extensionSampleIndex = ret.frequencyIndex - 3;
          } else {
            ret.audioObjectType = 2;
            config = new Array(2);
            extensionSampleIndex = ret.frequencyIndex;
          }
        } else if (userAgent.indexOf('android') !== -1 || userAgent.indexOf('safari') !== -1) {
          ret.audioObjectType = 2;
          config = new Array(2);
          extensionSampleIndex = ret.frequencyIndex;
        } else {
          ret.audioObjectType = 5;
          config = new Array(4);
          if (ret.frequencyIndex >= 6) {
            extensionSampleIndex = ret.frequencyIndex - 3;
          } else {
            if (ret.channel === 1) {
              ret.audioObjectType = 2;
              config = new Array(2);
            }
            extensionSampleIndex = ret.frequencyIndex;
          }
        }

        config[0] = ret.audioObjectType << 3;
        config[0] |= (ret.frequencyIndex & 0x0e) >> 1;
        config[1] = (ret.frequencyIndex & 0x01) << 7;
        config[1] |= ret.channel << 3;
        if (ret.audioObjectType === 5) {
          config[1] |= (extensionSampleIndex & 0x0e) >> 1;
          config[2] = (extensionSampleIndex & 0x01) << 7;
          config[2] |= 2 << 2;
          config[3] = 0;
        }

        ret.audioConfig = config;
      }
    }]);

    return TsDemuxer;
  }();

  var _createClass$2 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Playlist = function () {
    function Playlist(configs) {
      _classCallCheck$2(this, Playlist);

      this._baseURL = '';
      this._list = {};
      this._ts = {};
      this.version = 0;
      this.sequence = -1;
      this.targetduration = 0;
      this.duration = 0;
      this.fragLength = 0;
      this._lastget = undefined;
      this._audoclear = configs.autoclear || false;
      this.downloadedUrls = [];
    }

    _createClass$2(Playlist, [{
      key: 'push',
      value: function push(ts, duration, discontinue) {
        if (!this._ts[ts]) {
          this._ts[ts] = { duration: duration,
            downloaded: false,
            downloading: false,
            start: this.duration,
            discontinue: !!discontinue
          };
          this._list[this.duration] = ts;
          this.duration += duration;
          this.fragLength += 1;
        }
      }
    }, {
      key: 'deleteFrag',
      value: function deleteFrag(url) {
        if (this._ts[url]) {
          if (this._ts[url].start > this._lastget.time) {
            this._lastget = {
              duration: this._ts[url].duration,
              time: this._ts[url].start,
              downloaded: false,
              downloading: false,
              url: url
            };
          }
          delete this._list[this._ts[url].start];
          delete this._ts[url];
          this.fragLength -= 1;
        }
      }
    }, {
      key: 'pushM3U8',
      value: function pushM3U8(data, deletepre) {
        // 常规信息替换
        if (!data) {
          throw new Error('No m3u8 data received.');
        }
        this.version = data.version;
        this.targetduration = data.targetduration;
        if (data.encrypt && !this.encrypt) {
          this.encrypt = data.encrypt;
        }

        if (!data.sequence) {
          data.sequence = 0;
        }

        // 新分片信息
        if (data.sequence >= this.sequence) {
          this.sequence = data.sequence;
          var newfraglist = [];
          for (var i = 0; i < data.frags.length; i++) {
            var frag = data.frags[i];
            if (!this._ts[frag.url] && this.downloadedUrls.indexOf(frag.url) < 0) {
              newfraglist.push(frag.url);
              this.push(frag.url, frag.duration, frag.discontinue);
            }
          }

          if (newfraglist.length < 1) {
            throw new Error('Can not read ts file list.');
          }

          if (deletepre) {
            var tslist = this.getTsList();
            for (var _i = 0; _i < tslist.length; _i++) {
              if (newfraglist.indexOf(tslist[_i]) < 0) {
                this.deleteFrag(tslist[_i]);
              }
            }
          }
        } else {
          throw new Error('Old m3u8 file received, ' + data.sequence);
        }
      }
    }, {
      key: 'getTsList',
      value: function getTsList() {
        return Object.keys(this._ts);
      }
    }, {
      key: 'downloaded',
      value: function downloaded(tsname, isloaded) {
        var ts = this._ts[tsname];
        if (ts) {
          ts.downloaded = isloaded;
        }
      }
    }, {
      key: 'downloading',
      value: function downloading(tsname, loading) {
        var ts = this._ts[tsname];
        if (ts) {
          ts.downloading = loading;
        }
      }
    }, {
      key: 'getTsByName',
      value: function getTsByName(name) {
        return this._ts[name];
      }
    }, {
      key: 'getTs',
      value: function getTs(time) {
        var timelist = Object.keys(this._list);
        var ts = void 0;

        if (time === undefined) {
          if (this._lastget) {
            time = this._lastget.time + this._lastget.duration;
          } else {
            time = 0;
          }
        }

        if (timelist.length < 1 || time >= this.duration) {
          return undefined;
        }
        timelist = timelist.sort(function (a, b) {
          return parseFloat(a) - parseFloat(b);
        });
        for (var i = 0; i < timelist.length; i++) {
          if (time >= parseInt(timelist[i])) {
            var url = this._list[timelist[i]];
            var downloaded = this._ts[url].downloaded;
            var downloading = this._ts[url].downloading;
            ts = { url: url, downloaded: downloaded, downloading: downloading, time: parseInt(timelist[i]), duration: parseInt(this._ts[url].duration) };
            if (this.autoclear) {
              delete this._ts[this._lastget.url];
              delete this._list[this._lastget.time];
            }
            this._lastget = ts;
          } else {
            break;
          }
        }
        if (ts) {
          this.downloadedUrls.push(ts.url);
        }
        return ts;
      }
    }, {
      key: 'getLastDownloadedTs',
      value: function getLastDownloadedTs() {
        var timelist = Object.keys(this._list);
        var found = void 0;
        for (var i = 0; i < timelist.length; i++) {
          var url = this._list[timelist[i]];
          var downloaded = this._ts[url].downloaded;
          var downloading = this._ts[url].downloading;
          if (downloaded) {
            found = { url: url, downloaded: downloaded, downloading: downloading, time: parseInt(timelist[i]), duration: parseInt(this._ts[url].duration) };
          } else {
            break;
          }
        }

        return found;
      }
    }, {
      key: 'clear',
      value: function clear() {
        this._baseURL = '';
        this._list = {};
        this._ts = {};
        this.version = 0;
        this.sequence = -1;
        this.targetduration = 0;
        this.duration = 0;
      }
    }, {
      key: 'clearDownloaded',
      value: function clearDownloaded() {
        for (var i = 0, l = Object.keys(this._ts).length; i < l; i++) {
          var ts = this._ts[Object.keys(this._ts)[i]];
          ts.downloaded = false;
          ts.downloading = false;
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this._baseURL = '';
        this._list = {};
        this._ts = {};
        this.version = 0;
        this.sequence = -1;
        this.targetduration = 0;
        this.duration = 0;
        this.fragLength = 0;
        this._lastget = undefined;
        this._audoclear = false;
      }
    }, {
      key: 'list',
      get: function get() {
        return this._list;
      }
    }, {
      key: 'baseURL',
      set: function set(baseURL) {
        if (this.baseURL !== baseURL) {
          this.clear();
          this._baseURL = baseURL;
        }
      },
      get: function get() {
        return this._baseURL;
      }
    }]);

    return Playlist;
  }();

  var _createClass$3 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var LOADER_EVENTS$2 = EVENTS.LOADER_EVENTS;
  var DEMUX_EVENTS$2 = EVENTS.DEMUX_EVENTS;
  var HLS_EVENTS$1 = EVENTS.HLS_EVENTS;
  var CRYTO_EVENTS$1 = EVENTS.CRYTO_EVENTS;
  var HLS_ERROR = 'HLS_ERROR';

  var HlsLiveController = function () {
    function HlsLiveController(configs) {
      _classCallCheck$3(this, HlsLiveController);

      this.configs = Object.assign({}, configs);
      this.url = '';
      this.baseurl = '';
      this.sequence = 0;
      this._playlist = null;
      this.retrytimes = this.configs.retrytimes || 3;
      this.preloadTime = this.configs.preloadTime;
      this._m3u8lasttime = 0;
      this._timmer = setInterval(this._checkStatus.bind(this), 50);
      this._lastCheck = 0;
      this._player = this.configs.player;
      this.m3u8Text = null;

      this.setDataInterval = null;
    }

    _createClass$3(HlsLiveController, [{
      key: 'init',
      value: function init() {
        // 初始化Buffer （M3U8/TS/Playlist);
        this._context.registry('M3U8_BUFFER', XgBuffer);
        this._context.registry('TS_BUFFER', XgBuffer);
        this._context.registry('TRACKS', Tracks__default);

        this._playlist = this._context.registry('PLAYLIST', Playlist)({ autoclear: true });

        // 初始化M3U8Loader;
        this._m3u8loader = this._context.registry('M3U8_LOADER', FetchLoader)({ buffer: 'M3U8_BUFFER', readtype: 1, retryTime: 0 });
        this._tsloader = this._context.registry('TS_LOADER', FetchLoader)({ buffer: 'TS_BUFFER', readtype: 3, retryTime: 1 });

        // 初始化TS Demuxer
        this._context.registry('TS_DEMUXER', TsDemuxer)({ inputbuffer: 'TS_BUFFER' });

        this.initEvents();
      }
    }, {
      key: 'initEvents',
      value: function initEvents() {
        this.on(LOADER_EVENTS$2.LOADER_COMPLETE, this._onLoadComplete.bind(this));

        this.on(DEMUX_EVENTS$2.METADATA_PARSED, this._onMetadataParsed.bind(this));

        this.on(DEMUX_EVENTS$2.SEI_PARSED, this._handleSEIParsed.bind(this));

        this.on(DEMUX_EVENTS$2.DEMUX_COMPLETE, this._onDemuxComplete.bind(this));

        this.on(LOADER_EVENTS$2.LOADER_ERROR, this._onLoadError.bind(this));

        this.on(DEMUX_EVENTS$2.DEMUX_ERROR, this._onDemuxError.bind(this));
      }
    }, {
      key: '_onError',
      value: function _onError(type, mod, err, fatal) {
        var error = {
          errorType: type,
          errorDetails: '[' + mod + ']: ' + (err ? err.message : ''),
          errorFatal: fatal
        };
        this._player.emit(HLS_ERROR, error);
      }
    }, {
      key: '_onDemuxComplete',
      value: function _onDemuxComplete() {
        var _this = this;

        if (this._player.video) {
          var _context$getInstance = this._context.getInstance('TRACKS'),
              videoTrack = _context$getInstance.videoTrack,
              audioTrack = _context$getInstance.audioTrack;

          videoTrack.samples.forEach(function (sample) {
            if (sample.analyzed) {
              return;
            }
            sample.analyzed = true;
            var buffer = new Stream(sample.data.buffer);
            var nals = void 0;
            if (_this._isHEVC(videoTrack.meta)) {
              nals = xgplayerTransmuxerCodecHevc.NalUnitHEVC.getHvccNals(buffer);
            } else {
              nals = xgplayerTransmuxerCodecAvc.NalUnit.getAvccNals(buffer);
            }
            var nalsLength = nals.reduce(function (len, current) {
              return len + 4 + current.body.byteLength;
            }, 0);
            var newData = new Uint8Array(nalsLength);
            var offset = 0;
            nals.forEach(function (nal) {
              newData.set([0, 0, 0, 1], offset);
              offset += 4;
              newData.set(new Uint8Array(nal.body), offset);
              offset += nal.body.byteLength;
            });

            sample.data = newData;
          });
          if (this.setDataInterval) {
            return;
          }
          this.setDataInterval = setInterval(function () {
            if (videoTrack.samples.length || audioTrack.samples.length) {
              _this._player.video.onDemuxComplete(videoTrack, audioTrack);
            } else {
              clearInterval(_this.setDataInterval);
              _this.setDataInterval = null;
            }
          }, 200);
        }
      }
    }, {
      key: '_onMetadataParsed',
      value: function _onMetadataParsed(type) {
        if (type === 'audio') {
          // 将音频meta信息交给audioContext，不走remux封装
          var _context$getInstance2 = this._context.getInstance('TRACKS'),
              audioTrack = _context$getInstance2.audioTrack;

          if (audioTrack && audioTrack.meta) {
            this._setMetaToAudio(audioTrack.meta);
          }
        } else {
          var _context$getInstance3 = this._context.getInstance('TRACKS'),
              videoTrack = _context$getInstance3.videoTrack;

          if (videoTrack && videoTrack.meta) {
            this._setMetaToVideo(videoTrack.meta);
          }
        }
      }
    }, {
      key: '_setMetaToAudio',
      value: function _setMetaToAudio(audioMeta) {
        if (this._player.video) {
          this._player.video.setAudioMeta(audioMeta);
        }
      }
    }, {
      key: '_setMetaToVideo',
      value: function _setMetaToVideo(videoMeta) {
        if (this._player.video) {
          this._player.video.setVideoMeta(videoMeta);
        }
      }
    }, {
      key: '_onLoadError',
      value: function _onLoadError(loader, error) {
        if (loader !== 'M3U8_LOADER') {
          this.retrytimes = 3;
          return;
        }
        if (!this._tsloader.loading && !this._m3u8loader.loading && this.retrytimes > 1) {
          this.retrytimes--;
          this._onError(LOADER_EVENTS$2.LOADER_ERROR, loader, error, false);
        } else if (this.retrytimes <= 1) {
          this.retrytimes--;
          this._onError(LOADER_EVENTS$2.LOADER_ERROR, loader, error, true);
          this.emit(HLS_EVENTS$1.RETRY_TIME_EXCEEDED);
          if (this._player.video) {
            this._player.video.handleEnded();
          }
        }
      }
    }, {
      key: '_onDemuxError',
      value: function _onDemuxError(mod, error, fatal) {
        if (fatal === undefined) {
          fatal = true;
        }
        this._onError(LOADER_EVENTS$2.LOADER_ERROR, mod, error, fatal);
      }
    }, {
      key: '_handleSEIParsed',
      value: function _handleSEIParsed(sei) {
        this._player.emit('SEI_PARSED', sei);
      }
    }, {
      key: '_onLoadComplete',
      value: function _onLoadComplete(buffer) {
        if (buffer.TAG === 'M3U8_BUFFER') {
          var mdata = void 0;
          try {
            this.m3u8Text = buffer.shift();
            mdata = M3U8Parser.parse(this.m3u8Text, this.baseurl);
          } catch (error) {
            this._onError('M3U8_PARSER_ERROR', 'M3U8_PARSER', error, false);
          }

          if (!mdata) {
            if (this.retrytimes > 0) {
              this.retrytimes--;
              this._preload();
            } else {
              this.emit(HLS_EVENTS$1.RETRY_TIME_EXCEEDED);
              if (this._player.video) {
                this._player.video.handleEnded();
              }
            }
            return;
          }

          try {
            this._playlist.pushM3U8(mdata, true);
          } catch (error) {
            this._onError('M3U8_PARSER_ERROR', 'PLAYLIST', error, false);
          }

          if (this._playlist.encrypt && this._playlist.encrypt.uri && !this._playlist.encrypt.key) {
            this._context.registry('DECRYPT_BUFFER', XgBuffer)();
            this._context.registry('KEY_BUFFER', XgBuffer)();
            this._tsloader.buffer = 'DECRYPT_BUFFER';
            this._keyLoader = this._context.registry('KEY_LOADER', FetchLoader)({ buffer: 'KEY_BUFFER', readtype: 3 });
            this.emitTo('KEY_LOADER', LOADER_EVENTS$2.LADER_START, this._playlist.encrypt.uri);
          } else {
            this._m3u8Loaded(mdata);
          }
        } else if (buffer.TAG === 'TS_BUFFER') {
          this.retrytimes = this.configs.retrytimes || 3;
          this._playlist.downloaded(this._tsloader.url, true);
          this.emit(DEMUX_EVENTS$2.DEMUX_START);
        } else if (buffer.TAG === 'DECRYPT_BUFFER') {
          this.retrytimes = this.configs.retrytimes || 3;
          this._playlist.downloaded(this._tsloader.url, true);
          this.emitTo('CRYPTO', CRYTO_EVENTS$1.START_DECRYPT);
        } else if (buffer.TAG === 'KEY_BUFFER') {
          this.retrytimes = this.configs.retrytimes || 3;
          this._playlist.encrypt.key = buffer.shift();
          this._crypto = this._context.registry('CRYPTO', Crypto)({
            key: this._playlist.encrypt.key,
            iv: this._playlist.encrypt.ivb,
            method: this._playlist.encrypt.method,
            inputbuffer: 'DECRYPT_BUFFER',
            outputbuffer: 'TS_BUFFER'
          });
          this._crypto.on(CRYTO_EVENTS$1.DECRYPTED, this._onDcripted.bind(this));
        }
      }
    }, {
      key: '_onDcripted',
      value: function _onDcripted() {
        this.emit(DEMUX_EVENTS$2.DEMUX_START);
      }
    }, {
      key: '_m3u8Loaded',
      value: function _m3u8Loaded(mdata) {
        if (!this.preloadTime) {
          this.preloadTime = this._playlist.targetduration ? this._playlist.targetduration : 5;
        }
        if (this._playlist.fragLength > 0 && this._playlist.sequence < mdata.sequence) {
          this.retrytimes = this.configs.retrytimes || 3;
        } else {
          if (this.retrytimes > 0) {
            this.retrytimes--;
            this._preload();
          } else {
            this.emit(HLS_EVENTS$1.RETRY_TIME_EXCEEDED);
            if (this._player.video) {
              this._player.video.handleEnded();
            }
          }
        }
      }
    }, {
      key: '_checkStatus',
      value: function _checkStatus() {
        if (this._player.paused) {
          return;
        }

        if (this.retrytimes < 1 && new Date().getTime() - this._lastCheck < 4000) {
          return;
        } else if (this.retrytimes < 1) {
          window.clearInterval(this._timmer);
        }
        this._lastCheck = new Date().getTime();
        if (this._player.buffered.length < 1) {
          this._preload();
        } else {
          // Check for load.
          var currentTime = this._player.currentTime;
          var bufferstart = this._player.buffered.start(this._player.buffered.length - 1);
          if (this._player.readyState <= 2) {
            if (currentTime < bufferstart) {
              this._player.currentTime = bufferstart;
              currentTime = bufferstart;
            } else {
              this._preload();
            }
          }
          var bufferend = this._player.buffered.end(this._player.buffered.length - 1);
          if (currentTime > bufferend - this.preloadTime) {
            this._preload();
          }
        }
      }
    }, {
      key: '_preload',
      value: function _preload() {
        if (this.retrytimes < 1 || this._tsloader.loading || this._m3u8loader.loading) {
          return;
        }
        var frag = this._playlist.getTs();

        if (frag && !frag.downloaded && !frag.downloading) {
          this._playlist.downloading(frag.url, true);
          this.emitTo('TS_LOADER', LOADER_EVENTS$2.LADER_START, frag.url);
        } else {
          var preloadTime = this.preloadTime ? this.preloadTime : 0;
          var current = new Date().getTime();
          if ((!frag || frag.downloaded) && (current - this._m3u8lasttime) / 1000 > preloadTime) {
            this._m3u8lasttime = current;
            this.emitTo('M3U8_LOADER', LOADER_EVENTS$2.LADER_START, this.url);
          }
        }
      }
    }, {
      key: '_isHEVC',
      value: function _isHEVC(meta) {
        return meta && meta.codec === 'hev1.1.6.L93.B0';
      }
    }, {
      key: 'load',
      value: function load(url) {
        this.baseurl = M3U8Parser.parseURL(url);
        this.url = url;
        this._preload();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        clearInterval(this._timmer);
        this.off(LOADER_EVENTS$2.LOADER_COMPLETE, this._onLoadComplete);
        // this.off(REMUX_EVENTS.REMUX_ERROR);
        this.off(DEMUX_EVENTS$2.METADATA_PARSED, this._onMetadataParsed);
        this.off(DEMUX_EVENTS$2.DEMUX_COMPLETE, this._onDemuxComplete);

        this.m3u8Text = null;
      }
    }]);

    return HlsLiveController;
  }();

  var _createClass$4 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
  var hlsAllowedEvents = EVENTS.HlsAllowedEvents;
  var BasePlugin = Player.BasePlugin;

  var HlsPlayer = function (_BasePlugin) {
    _inherits(HlsPlayer, _BasePlugin);

    function HlsPlayer() {
      _classCallCheck$4(this, HlsPlayer);

      return _possibleConstructorReturn(this, (HlsPlayer.__proto__ || Object.getPrototypeOf(HlsPlayer)).apply(this, arguments));
    }

    _createClass$4(HlsPlayer, [{
      key: 'beforePlayerInit',
      value: function beforePlayerInit() {
        var player = this.player;

        if (player.video) {
          player.video.setAttribute('preloadtime', this.config.preloadTime);
        }
        this.context = new Context(hlsAllowedEvents);
        this.initHls();
        this.context.init();
        this.loadData();
        this.initEvents();
      }
    }, {
      key: 'afterCreate',
      value: function afterCreate() {
        var _player = this.player,
            video = _player.video,
            config = _player.config;

        video.width = Number.parseInt(config.width || 600);
        video.height = Number.parseInt(config.height || 337.5);
        video.style.outline = 'none';
      }
    }, {
      key: 'initEvents',
      value: function initEvents() {
        var _this2 = this;

        this.play = this.play.bind(this);

        var player = this.player;


        player.on('seeking', function () {
          var time = _this2.currentTime;
          var range = player.getBufferedRange();
          if (time > range[1] || time < range[0]) {
            _this2.hls.seek(_this2.currentTime);
          }
        });

        player.on('play', this.play);
      }
    }, {
      key: 'initHls',
      value: function initHls() {
        var player = this.player,
            config = this.config;

        this.hls = this.context.registry('HLS_CONTROLLER', HlsLiveController)({ player: player, preloadTime: config.preloadTime, retryTimes: config.retryTimes });
      }
    }, {
      key: 'play',
      value: function play() {
        if (this.hls) {
          this.hls._onMetadataParsed('video');
          this.hls._onMetadataParsed('audio');
        }
      }
    }, {
      key: 'loadData',
      value: function loadData() {
        var player = this.player;

        if (this.hls) {
          this.hls.load(player.config.url);
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this._destroy();
      }
    }, {
      key: 'addLiveFlag',
      value: function addLiveFlag() {
        var player = this.player;

        Player.Util.addClass(player.root, 'xgplayer-is-live');
      }
    }, {
      key: '_destroy',
      value: function _destroy() {
        this.context.destroy();
        this.hls = null;
        this.context = null;
      }
    }, {
      key: 'switchURL',
      value: function switchURL(url) {
        var context = new Context(hlsAllowedEvents);
        var hls = context.registry('FLV_CONTROLLER', FLV)(this.player);
        context.init();
        this.this.hls = hls;
        this.initFlvBackupEvents(hls, context);
        hls.loadData(url);
      }
    }, {
      key: 'src',
      get: function get() {
        return this.player.currentSrc;
      },
      set: function set(url) {
        this.switchURL(url);
      }
    }], [{
      key: 'isSupported',
      value: function isSupported() {
        var wasmSupported = 'WebAssembly' in window;
        var WebComponentSupported = 'customElements' in window && window.customElements.define;
        var isComponentDefined = void 0;
        if (WebComponentSupported) {
          isComponentDefined = window.customElements.get('mobile-video');
        }
        return wasmSupported && isComponentDefined;
      }
    }, {
      key: 'pluginName',
      get: function get() {
        return 'hlsLiveMobile';
      }
    }, {
      key: 'defaultConfig',
      get: function get() {
        return {
          preloadTime: 4
        };
      }
    }]);

    return HlsPlayer;
  }(BasePlugin);

  return HlsPlayer;

})));
